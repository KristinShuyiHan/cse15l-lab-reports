# CSE15L Lab Report 5

## Comparing different implmentation with different results of MarkdownParse

Two links being compared are [mine](https://github.com/KristinShuyiHan/markdown-parse) and [Joes](https://github.com/ucsd-cse15l-w22/markdown-parse). To compare two implementations, I use thew following bash script provided by Joe.
```
for file in test-files/*.md;
do
  java MarkdownParse $file
done
```
This commands run `MarkdownParse`implementation through every single test in `test-files`directory. Then, to save the outputs for conparison, I use `the command bash script.sh > results.txt` to save Joe's Mkdp's ourput and `bash script.sh > result1.txt ` to save my Mkdp's output. Then, I type ```diff markdown-parse/result1.txt markdown-parseLab7/markdown-parse/results.txt``` command to compare the difference. The output shows difference in the way that listing my result at  a certain line number, then paced by a ---, and then the output of Commonmark. Then, I type `vim` to oepn the .txt files to locate the test by the given line number. Lastly, to quick search for the line number, I type in `:set number`.



## Difference 1: 487.md
My implementation had different answers than the implementation we provided for lab 9 at 487.md

According to [the output generated by the CommonMark demo site](https://spec.commonmark.org/dingus/),


![Image](https://github.com/KristinShuyiHan/cse15l-lab-reports/blob/main/Screen%20Shot%202022-03-14%20at%208.08.19%20PM.png)

the whole testfile as it neither creats a valid link name, nor valid link, so the correct output given by Markdownparse should be empty `[]`
However
```
Joe's Output
< [] test-files/487.md
---
My Output
> [/my uri]  test-files/487.md 
```
**Describe which implementation is correct, or if you think neither is correct, by showing both actual outputs and indicating what the expected output is.For the implementation that’s not correct (or choose one if both are incorrect), describe the _bug (the problem in the code). You don’t have to provide a fix, but you should be specific about what is wrong with the program, and show the code that should be fixed.**

Joe's output is correct here, and mine is false. The problem of my code is it picks up eveything between the left parenthesis and the right parenthesis next to it, without checking if content between the brackets have space, which makes a link invalid. This problem reveals an important loophoel in my implementation, which is I fail to take newline, special character, blank, and other many elements that might make a link invlaid. Professor Joe's code does take these situations into account. 

Fixing my code at line 17 might fix this problem, because I can store the substring arraylist into another variable, and then write down a series of if statement to check if the content of the variable has any element that might render the link to be invalid. The idea is learned from Joe's implementation where he has a line ```String potentialLink = markdown.substring(openParen + 1, closeParen).trim();``` which stores the substring into a temporary variable for further checking instead of directly adding substring to the variable that is going to be returned. To check if a ```potentialLink``` is valid, I will create a if statement, and adds conditaions into it, like what I did from line 15 to 17. 

```
 public class MarkdownParse {                                                    1
    public static ArrayList<String> getLinks(String markdown) {                  2
        ArrayList<String> toReturn = new ArrayList<>();                          3
        // find the next [, then find the ], then find the (, then take up to.   4
        // the next )                                                            5
        int currentIndex = 0;                                                    6
        while(currentIndex < markdown.length()) {                                7                            
            int nextOpenBracket = markdown.indexOf("[", currentIndex);           8
            int nextCloseBracket = markdown.indexOf("]", nextOpenBracket);       9
            int openParen = markdown.indexOf("(", nextCloseBracket);             10
            int closeParen = markdown.indexOf(")", openParen);                   11
            if(nextOpenBracket ==-1 || nextCloseBracket==-1){.                   12
                break;                                                           13
            }                                                                    14                                                           
 15       if (markdown.indexOf("!") != nextOpenBracket-1 && nextCloseBracket +1 == openParen && markdown.indexOf(".png",openParen) !=    closeParen-4){                                                                  
                toReturn.add(markdown.substring(openParen + 1, closeParen));     16
                }                                                                17
                currentIndex = closeParen + 1;                                   18
                System.out.println();                                            19
        }                                                                        20
        return toReturn;                                                         21

    }   
```



## Difference 2: 342.md

My implementation had different answers than the implementation we provided for lab 9 at 342.md at line 542

According to [the output generated by the CommonMark demo site](https://spec.commonmark.org/dingus/),


![Image](https://github.com/KristinShuyiHan/cse15l-lab-reports/blob/main/Screen%20Shot%202022-03-14%20at%208.08.59%20PM.png)

Although the test file generates an valid link name, since other than the file name, there is nothing bheind it in the file, so the implementation of MarkdownParse is supposed to generate `[]` as correct output, indicating there is no valid link.
However
```
Joe's Output
< []   test-files/342.md 
---
My Output
> [/foo`] test-files/342.md
```
**Describe which implementation is correct, or if you think neither is correct, by showing both actual outputs and indicating what the expected output is.For the implementation that’s not correct (or choose one if both are incorrect), describe the _bug (the problem in the code). You don’t have to provide a fix, but you should be specific about what is wrong with the program, and show the code that should be fixed.**

Joe's output os correct, and mine is not. The problem is similar to that in test 1 as my code picks up eveything between the pair of parenthesis as link. However,even if the problem mentioned in test is fixed, the output is still false because the reason that my code generates false output is not only it fails to check any invalid element inside the link, but also because I fail to consider the backtick coming in pairs form a valid link name, which means things, no matter what element it has, in between two backticks forming a link name.
To fix the problem, I should add another if statement check for matching set of backticks, and skip anything in between the set odf backticks when searching for a valid link. The part of the program that generate wrong link is between link 7 to link 12, where it fails to check the existence of backticks and ignores its effect. It should be fixed by adding a condition in front of line 8, where it firstly checks if a pair of backticks exist in the testfile, if so, it should do things similar to line 8 and line 9, which set a boundary for link name, except it should be variabe named '''nextOpenBacktick''' and '''nextCloseBacktick'''. 


```
 public class MarkdownParse {                                                    1
    public static ArrayList<String> getLinks(String markdown) {                  2
        ArrayList<String> toReturn = new ArrayList<>();                          3
        // find the next [, then find the ], then find the (, then take up to.   4
        // the next )                                                            5
        int currentIndex = 0;                                                    6
        while(currentIndex < markdown.length()) {                                7                            
            int nextOpenBracket = markdown.indexOf("[", currentIndex);           8
            int nextCloseBracket = markdown.indexOf("]", nextOpenBracket);       9
            int openParen = markdown.indexOf("(", nextCloseBracket);             10
            int closeParen = markdown.indexOf(")", openParen);                   11
            if(nextOpenBracket ==-1 || nextCloseBracket==-1){.                   12
                break;                                                           13
            }                                                                    14                                                           
 15       if (markdown.indexOf("!") != nextOpenBracket-1 && nextCloseBracket +1 == openParen && markdown.indexOf(".png",openParen) !=    closeParen-4){                                                                   16
                toReturn.add(markdown.substring(openParen + 1, closeParen));     17
                }                                                                18
                currentIndex = closeParen + 1;                                   19
                System.out.println();                                            20
        }                                                                        21
        return toReturn;                                                         22

    }   
```
